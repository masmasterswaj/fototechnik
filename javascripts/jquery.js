// JavaScript Document
/ *! jQuery v2.1.1 | (c) 2005, 2014 jQuery Foundation, Inc | jquery.org / licencji * /
! Funkcja (a, b) {"obiekt" == Moduł typeof && "obiekt" == typeof module.exports module.exports = a.document b (, 0!):?! Function () {if ( . dokument) throw new Error ("jQuery wymaga okno z dokumentem"); return b ()}: b ()} ("nieokreślone" = typeof okno okno: ta funkcja (a, b!) { var nowy d.call (to)}, otrzymujemy: function () {return NULL = 0> ta [+ this.length]:? to []: d.call (to)}, pushStack: funkcja () {var b = n.merge (this.constructor ()); powrót b.prevObject = to, b.context = this.context, b}, każdy: funkcja (a, b) {return n. każdy (w tym,, b)}, mapa: function () {return this.pushStack (n.map (ta funkcja (b, c) {return a.call (b, c, b)}))} Kromka: function () {return this.pushStack (d.apply (to argumenty))}, najpierw: function () {return this.eq (0)}, ostatni: function () {return this.eq (- 1)}, eq: function () {var b = this.length, c = + + (0> b:? 0); powrót this.pushStack (c> = 0 && b> c [ta [c]] : [])}, na koniec: function () {return , b, c, d, e, f, g = argumenty [0] | | {} = 1 h, i = arguments.length, j = 1! dla ("wartość logiczna" == typeof g && (j = g, g = argumenty [h] | | {}, h + +), "obiekt" == typeof g | | n.isFunction (g) | | (g = {}), h === i && (g = ta, h -) i> h, h + +) if (null! = (a = argumenty [h])) dla (bw 0 == d && (g [b] = d)); powrót g}, n.extend ({EXPANDO: "jQuery" + (m + Math.random ())!. Replace (/ \ D / g, "" ), isReady: 0, błąd: function () {throw new b; dla (bw) return 1; return 0}, typu: function () {return NULL == + "": "obiekt" == typeof | | "funkcja" == typeof!? ? h [i.call ()] | | "obiekt": typeof}, globalEval: function () {var b, c = eval; = n.trim () && (1 === a . indexOf ("Wykorzystanie a.replace (p, "MS"), wymienić (q, r)} nodeName:. funkcji (b) {powrotu a.nodeName && a.nodeName.toLowerCase () === b.toLowerCase ()}, każde : Zastosowanie (a, b, c) {var d, e = 0, m = a.length, g = y () if (c) {if (g) {for (, f> e, e +), czy (d = b.apply ([e], c), d ===! 1) Przerwa} else do (e), jeśli w (d = b.apply ([e], c), d == ! = 1) break} else if (g) {for (; f> e, e + +) if (d = b.call ([e], e, [e]), d === 1) Przerwa! } else do (e), jeśli w (! d = b.call ([e], e, [e]), d === 1) break; powrócić}, wykończenia: function () {return ? wartość null == "": (a + "") zastąpi (o, "")}, makeArray:.! funkcja (a, b) {var c = b | | []; return NULL = && (y (Object ()) n.merge (c, "sznur" == typeof []:?) f.call (C)), c}, inArray: Zastosowanie (a, b, c) { zwrócenie null == b -1: g.call (b, c)}, scalanie: funkcja (a, b) {for (var c = + b.length, d = 0, e = a.length; c> d, d + +) [e + +] = b [d]; powrót a.length = e,}, grep: funkcja (a, b, c) {for (var d, e = [], f = 0 , g = a.length, h = c;! g> f;! f + +) d = b ([f], f), d == h && e.push ([f]);! powrócić e}, mapa : Zastosowanie (a, b, c) {var d, f = 0, g = a.length, h = s (a), i = [] if (h) (, g> f, f + +) d = ! b ([f], f, c), null = d && i.push (d);! indziej dla (f w punkcie a) d = b ([f], f, c), null = d && i.push ( d) powrót e.apply ([], i)}, GUID: 1, pełnomocnik: funkcja (a, b) {var c, e, f, powrót "ciąg" == typeof b && (c = [b] b = A = C), n.isFunction (?) (e = d.call (argumenty 2) f = funkcja () {powrót a.apply (b | | tego e.concat (d . połączeń (argumenty)))}, f.guid = a.guid = a.guid | | n.guid + +, f): void 0}, teraz: Date.now wsparcie: k}), n.each (" Funkcja logiczna Liczba String Array Data RegExp obiektu Error ". split (" "), funkcja (a, b) {h [" [obiekt "+ b +"] "] = b.toLowerCase ()}); funkcja y () {var b && b> 0 && b-1 a} var t = funkcja () {parametr b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r , s, t, u = "trzask" + datę, v = a.document, 0, x = 0, y = pl (), z = pl () = GB (), B = W = funkcja (a, b) {return b = 0, C = this.length c> b, b + +) if (w [b] ===) powrót RegExp ("^" + M + "+ | ((:?. ^ | [^ \ \ \ \]) (: \ \ \ \) *)" + M + "+ $", "g"), S = Nowy RegExp ("^" + M + "*" + M + "*"), T = nowy RegExp ("^" + M + "* ([> + ~] |" + M + ")" + M + "*") U = nowy RegExp ("=" + M + "* ([^ \ \] '\"] *?) "+ M +" * \ \] "," g "), V = nowy RegExp (Q), W = new RegExp ("^" + O + "$"), X = {ID: nowy RegExp ("^ # (" + n + ")"), Klasa: nowy RegExp (". ^ \ \ (" + n + ") "), TAG: nowy RegExp (" ^ ("+ N.replace (" w "," w * ") +") "), ATTR: nowy RegExp (" ^ "+ P), pseudonim: nowy RegExp (" ^ "+ Q), dzieci: nowy RegExp ("^ (:" + L + ") $", "i"), needsContext: nowy \ M /, _ = / ^ (:. # ([\ W-] +) | (\ w +) | \ ([\ w-] +)) $ /, ab = / [+ ~] / bb = / '| \ \ / g, cb = new RegExp ("\ \ \ \ ([\ \ da-f] {1,6}" + M + "|? (" + M + ") |.)", " IG "), db = funkcja (a, b, c) {var d =" 0x "+ B-65536; powrót a.length c = d = 0, podczas gdy ([C + +] = B [d +]); a.length = c-1}}} funkcji fb (a, b, d, e) {var f, h, J, K, L, O, R, S, W, X, jeśli ((b b.ownerDocument | | b?! v) == n && m (b), b = b | | n, d = d | | [],, | | "ciąg" = typeof) powrót d, jeśli (h.id === j) d.push powrotu (h), d} else if (b.ownerDocument && (h = b.ownerDocument.getElementById (j)) && t (b, h) && h.id = == j) d.push powrotu (h), d} else {if (f [2]) powrót I.apply (d, w.querySelectorAll (x)), d} catch (r) {} finally {r | | b.removeAttribute ("id")}}} return i (a.replace (R, "$ 1" ), b, PL D, e)} function () {var a = []; funkcja b (c, e) {return a.push (c + "")> d.cacheLength && b [a.shift usunąć ()], b [c + ""] = e} return b} Funkcja hb () {return [u] =! 0,} ib function () {var jb (b) {var c = a.split ("|") e = a.length, natomiast (e -) d.attrHandle [c [e]] = B} funkcji kb (b) {var c = b &&, d = c && 1 === a.nodeType && 1 === b.nodeType && (~ b.sourceIndex | | D) - (~ a.sourceIndex | | D) if (d) powrót d if ( c) podczas gdy (c = c.nextSibling) if (c === b) zwróci-1; powrót 1: -1} Funkcja lb () {function return (b) {var c = b.nodeName.toLowerCase? (); return "wejście" === c && b.type ===}} mb funkcja () {function return (b) {var c = b.nodeName.toLowerCase (); return ("wejście" === c | | "przycisk" === c) && b.type ===}} Funkcja nb () {HB powrotu (funkcja (b) {return b = a + b, hb (function (c, d) {var e, f = ([], c.length, b), g = f.length,! while (g -) c [e = f. [g]] && (C [k] = (D [k] = c [e]))})})} function ob () {return && typeof a.getElementsByTagName! == C &&} = c = fb.support {} f = fb.isXML = function () {var b = && (a.ownerDocument | |) documentElement; powrót b "Kopiuj" == b.nodeName:.?! 1}, m = fb.setDocument = function () {var b, e =?. ownerDocument | |: v, g = e.defaultView; powrót a.className = "ja",! a.getAttribute ("className")}), c.getElementsByTagName = IB (function () {return a.innerHTML = "<div class='a'> </ div> <div class = ' ! b.getElementById == C && p) {var c = b.getElementById (); return c && c.parentNode [c]: [?]}}, d.filter.ID = function () {var b = a.replace (cb, db); funkcja return () {return a.getAttribute ("id") === b}}): (usunąć d.find.ID, d.filter.ID = function () {var b = a.replace (cb, db); funkcja return () {var c = typeof a.getAttributeNode == C && a.getAttributeNode ("id");! powrócić c && c.value === b}}), d.find . TAG = funkcja c.getElementsByTagName (b) {powrotu typeof b.getElementsByTagName == b.getElementsByTagName () C: próżnia 0}:? funkcji (b) {var c, d = [] e = 0, f = b.getElementsByTagName (); if ("*" ===) {while (c = f [e + +]) 1 === c.nodeType && d.push (c);} return return d f}, d.find.CLASS = c.getElementsByClassName funkcja && (a, b) {return typeof b.getElementsByClassName == C && p b.getElementsByClassName ():? void 0}, r = [], q = [], ( c.qsa = $. testu (e.querySelectorAll)) && (ib (function () {a.innerHTML = "<wybierz msallowclip=''> <opcja RegExp (q.join ("|")), r = r.length && nowy RegExp (r.join ("|")), b = $ testu (o.compareDocumentPosition), t = b |. |. $ Test (o .? zawiera) funkcja (a, b) {var c = 9 === a.nodeType a.documentElement: A, D = b && b.parentNode; powrót l = 0,0;! var d = a.compareDocumentPosition-! b.compareDocumentPosition;! powrót l = 0,0 var c, d = 0, m = a.parentNode, g = b.parentNode, h = [a], i = [b];! (! f | | g) na powrót = ? == e -1: b === e 1: f -1: g 1: k K.call (k)-K.call (k, b):?? 0; if (f = == g) powrót d kb (h [d] i [d]):? h [d] === v -1: i [d] === v 01:00}, e): n}, fb.matches = funkcja (a, b) {return d = s.call (a, b) if (! d | | c.disconnectedMatch | | a.document && 11 == a.document.nodeType) powrót d} catch (e) {} return e = d.attrHandle [b.toLowerCase ()], f = e && E.call (d.attrHandle, b.toLowerCase ()) e (a, b, p!): void 0; return void nowy błąd ("Błąd składni, nierozpoznany wyraz:" +)}, fb.uniqueSort = function () {var k = null}, e = fb.getText = function () {var b, c = "", d = 0, f = a.nodeType if (f) {if (1 === f | | 9 === F | | 11 === f) {if ("ciąg" == typeof a.textContent) a.textContent powrotu; dla (= a.firstChild;; = a.nextSibling) c + = e ()} else if (3 === F | | 4 === f) powrót a.nodeValue} else if (b = [d + +]) c + = e (b); powrót [1] = [1] Wymienić (cb, db), [3] =.. ([3] | | [4] | | [5] | | "") zastąpi (CB, dB ), "~ =" === [2] && ([3] = "" + [3] + ""), a.slice (0,4)}, DZIECKO: function () {return b, c = [6] && [2];! powrót .? (cb, db) toLowerCase () b = a.replace; powrót "*" === function () {! return 0}: function () {return a.nodeName && a.nodeName.toLowerCase () == = b}}, Klasa: function () {var b = r [+ ""]; powrót b | | (b = new RegExp ("(^ |" + M + ")" + + "(" + M + " | $) ")) && y (funkcja () {return b.test (" ciąg "== typeof a.className && a.className | | typeof a.getAttribute == C && a.getAttribute (" Klasa ") | | "")})}, ATTR: funkcja (a, b, c) {funkcja return (d) {var e = fb.attr (d,); powrót "+ + E" f = "n-ty" == a.slice (0,3), g = "ostatni" == a.slice (-4), h = "of-type" === b;! zwraca 1 === ? Funkcja D && 0 === e () {return a.parentNode!}: funkcja (b, c, i) {var if (y && (j = (b [u] | | (b [u] = {})) []) && j [0] === W) m = j [1]; indziej m-= e, m === D | | m% d === 0 && m / d> = 0}}}, pseudonim: funkcja (a, b) {var c, e = d.pseudos [] | | d.setFilters [a.toLowerCase ()] | | fb.error ("nieobsługiwany pseudo:" +); powrócić e [u] e (b):? e.length> 1 (c = [,, "" b] d.setFilters.hasOwnProperty (a.toLowerCase ()) HB (funkcja (c) {var d, e, f = (b) g = f.length;? while (g -) d = K.call (f [g]), [D] = (C [D] = f [g])}): function () {return e (, 0, c) }): E}}, pseudos: {nie: HB (function () {var b = [], c = [], d = h (a.replace (R, "$ 1")); powrót d [u ?] hb (funkcja (a, b, c, e) {var f, g = d (null, e, []), h = a.length, natomiast (h -) (f = g [h ]) && ([h] = (b [h] = f!))}): funkcja (a, e, f) {return b [0] = d (b, null, f, c), ! c.pop ()}}), zawiera: HB (function () {function return (b) {fb powrotu (a, b) długość}), zawiera> 0}:. hb (function () {return funkcja (b) {return (b.textContent | | b.innerText | | e (b)) indexOf ()> -1.}}), lang: HB (function () {return W.test (| | "") | | fb.error ("nieobsługiwany lang:". +), = a.replace (cb, db) toLowerCase (), funkcja (b) {var c; zrobić, jeśli (b c = p? . lang: b.getAttribute ("xml: lang") | | b.getAttribute ("język")) return c = a.location && a.location.hash; powrócić c && c.slice (1) === b.id}, korzeń: function () {return a === O}, ostrość: function () {return a.disabled === 1}, wyłączone:! function () {return a.disabled === 0}, sprawdzone: function () {var Z.test (a.nodeName)}, wejście: function () {return Y.test (a.nodeName)}, przycisk: function () {var b = a.nodeName.toLowerCase (); return "wejście" === b && "przycisk" === a.type | | "przycisk" === b}, tekst: function () {var c = 0, b> c, c + = 2) a.push (c), z powrotem}) odd: nb (funkcja (b) {for (var c = 1, b> c, c + = 2) a.push (c); powrót}), lt: nb (function (a, b, c) {for (var d = 0> c c + b: c; - d> = 0 ;). Push (d); zwracają}), GT: NB (function (a, b, c) {for (var d = 0> c c + b: c, + d <b ;) a.push (d ); powrót})}}, d.pseudos.nth = d.pseudos.eq; dla (bw {radia:!! 0, pole wyboru: 0, plik: 0, hasło: 0, zdjęć: 0 }) d.pseudos [b] = kg (b), w przypadku (b w {przedłożyć: 0, reset:! 0}) d.pseudos [b] = mb (b); Funkcja PB () {} pb. Prototyp = d.filters = d.pseudos, d.setFilters = nowy pb, g = fb.tokenize = funkcja (b) {var c, e, f, g, h, i, j, k = Z [+ ""]; if (k) zwrot ")}), H = h.slice (c.length)), dla (gw b h.length: h fb.error ():?. oo (, i), plaster (0);} Funkcja QB () {for (var b = 0, c = a.length D = " "c> b, b +) D + = [b] Wartość;. powrotu d}, funkcja rb (a, b, c) {var b.dir d = e = c &&" parentNode "=== d, f = x +; powrót b.first funkcji (b, c, f) {if (B = b. [d]), w przypadku (1 === b.nodeType | | e) zwracają (b, c, f)}: Funkcja (b, c, g) {var h, i, j = [E, K] if (g) {if (B = b. [d]) if ((1 === b.nodeType | | e) && (b, c, g)) return 0;} else if (B = b. [d]), w przypadku (1 === b.nodeType |! | e) {if (i = b [u] | | (b [u ] = {}), (h = i [d]) && h [0] === W && h [1] === f) zwrot j [2] = h [2]; if (i [d] = j, j [2] = (b, c, g)) return 0}}} Funkcja SB () {a.length powrót> 1 funkcja (b, c, d) {var e = a.length;! podczas (e -), jeśli powrót 1; return 0}: [0]} function tb (a, b, c) {for (var d = 0 ([e] (b, c, d!))! e = b.length, e> d, d +) fb (b [d], c) zwrotny c} funkcji ub (a, b, c, d, e) {for (var f, g = [ !] h = 0, i = a.length, J = NULL = b, i> h, h + +) (+ + f = [h]) && (c | | c (F, d, e)) && ( g.push (f), j && b.push (h)); (!, b, c, d, e, f) {return d && d [u] && (d = czas (d) powrót g} Funkcja czas) e &&! e [u] && (e = czas (e, f)), HP (funkcja (f, g, h, i) {var r = ub (r === g r.splice (o, r.length): r)?, e e (null, g, r, i): I.apply (g, r)})} function wb () {for (var b, c, e, f = a.length, g = d.relative [[0] Typ.], h = g | | d.relative [""], i = g? 1:0, k = rb (function () {return a === b}, h,! 0), l = rb (function () {return . czas (i> 1 && SB (m), i> 1 && QB (a.slice (0, i-1) concat ({wartość: " SB (m)} function xb (b) {var b.length c => 0, e = a.length> 0, m = funkcja (f, g, h, i, k) {var k && (w = v, j = t), r}; return c hb (f): f} return h = fb.compile = funkcja (a, b) {var c, d = [], e = [] f = [+ " f}, i = fb.select = funkcja (a, b, e, f) {var I, J, K, L, M, n = "funkcja" == typeof 1 & a.compareDocumentPosition (n.createElement ("div"))}), IB (function () {return a.innerHTML = "< ? c void 0: a.getAttribute (? b, "typ" === b.toLowerCase () 1:2)}), c.attributes && IB (function () {return c | | "wejście" == a.nodeName.toLowerCase () void 0:? a.defaultValue}), IB (function () {wartość null powrót == a.getAttribute ("wyłączone")}) | | jb (L, funkcja (a, b, c) {var d;? powrót c nieważne u = n.expr.match.needsContext, v = / ^ <(\ w +) \ s * \ /> (: ​​<\ / \ 1> |). $ /, w = / ^ [^: # \ [\,.] * $ /;! funkcja x (a, b, c) {if (n.isFunction (b)) n.grep powrotu (funkcja (a, d) {return b.call ( !, d,) == c}); if (b.nodeType) n.grep powrotu (funkcja () {return a === b == c}); if ("ciąg" == typeof b) {if (w.test (b)) n.filter powrotu (b, c), b = n.filter (b)} n.grep powrotu (funkcja () {return g . połączeń (b)> = 0 == c})} n.filter = funkcja (a, b, c) {var d = b [0];! powrót 1 === a.nodeType}))}, n.fn.extend ({znaleźć: function () {var b, c = this.length, d = [], to e = if ("ciąg"! = typeof) powrót d = this.pushStack (c> 1 n.unique (d): d), d.selector = this.selector this.selector + "" +: d}, filtr: function () {powrót tego . pushStack (x (to, | | [], 1)!)}, nie: function () {return this.pushStack (x (to, | | [], 0)!)}, to: funkcja var y, z = /;}) |: () {. długość x (?! | [], 1 to "ciąg" == typeof && u.test () n ()) return!} ^ (: \ s * (<[\ w \ W] +>) [^>] * | # ([\ w-] *)) $ /, = n.fn.init = funkcja (a, b ) {var c, d; if () zwróci to, czy ("ciąg" == typeof instanceof wb) n.isFunction (ta [c]) to [c] (b [c]): this.attr (c, b [c]);} return zwrócić a.nodeType (this.context = w [0] =, this.length = 1, to)? n.isFunction () "nieokreślony" = typeof y.ready y.ready ()! (n): (void d = [], e = próżnia 0 == c,! while (! (= [b]) && 9 == a.nodeType), jeżeli (1 === a.nodeType) {if (e && n (). jest (c)) break; d.push ()} return d}, rodzeństwo: funkcja (a, b) {for (var c = [];; = a.nextSibling) 1 === a.nodeType && ! == b && c.push ();}} return c), n.fn.extend ({ma: function () {var b = n (to), c = b.length; powrócić this.filter (funkcja () {for (var a = 0, c>, + +) if (n.contains (to B [])) powrót 0!})} najbliżej: funkcyjnych (b) {for ( var c, d = 0, e = this.length, f = [], g = u.test () | |! "ciąg" = typeof this.pushStack (f.length> 1 n.unique (f): f)}, Indeks: function () {return to "ciąg" == typeof? this.pushStack (n.unique (n.merge (this.get () n (b))))} addBack: function () {powrót this.add (null == this.prevObject?: ! this.prevObject.filter ())}}) Funkcja D (b) {if ((= [b]) == 1 && a.nodeType) zwrócić} n.each ({macierzysty: function () {var b = a.parentNode; powrót b && 11 == b.nodeType b: null!}, rodzice: function () {n.dir powrotu ("parentNode")}, parentsUntil: funkcja ( a, b, c) {return n.dir ("parentNode", c)}, następny: function () {return D ("nextSibling")}, poprzednie: function () {return D ( , "PreviousSibling")}, nextAll: function () {n.dir powrotu ("nextSibling")}, prevAll: function () {n.dir powrotu ("previousSibling")}, nextUntil: funkcja ( a, b, c) {n.dir powrotu ("nextSibling", c)}, prevUntil: funkcja (a, b, c) {n.dir powrotu (A, "previousSibling", c)}, rodzeństwo: function () {return n.sibling (. (a.parentNode | | {}) firstChild,)}, dzieci: function () {return n.sibling (a.firstChild)} treść: function () {return a.contentDocument | | n.merge ([], a.childNodes)}}, function (a, b) {n.fn [] = function (c, d) {var e = n.map (ta , b, c);! powrót "do" == a.slice (-5) && (d = c), d && "string" == typeof E = / \ S + / g, F = {}; funkcja G () {var b = F [] = {}; powrót n.each (a.match (E) | | [], funkcja (, c) {b [c] = 0!}), b} n.Callbacks = funkcja () {= "sznur" == typeof F [] | | G (): n.extend ({ },); var c = h.length,! funkcja g (b) {n.each (b, funkcja (b, c) {var to}, usuń: function () {return h && n.each (argumenty, funkcja (a, b) {var ? n.inArray (h)> -1: (h | | h.length!)}, pusta: function () {return h = f [] = 0, to}, wyłączyć: funkcji ( ) {return h = i = 0 b = nieważne, to}, osób niepełnosprawnych: function () {return h!}, blokada: function () {return i = nieważne k.fireWith (this, argumenty), to}, wystrzelił: function () {return c}}; return k}, n.extend ({odroczony:! function () {var b = [["determinacja", "Gotowe", n.Callbacks ("raz pamięci"), "rozwiązany"], ["odrzucenie", "nie", n.Callbacks ("raz . c}, zawsze: function () {return e.done (argumenty) nie (argumenty), to}, to: function () {var a = argumenty; powrócić n.Deferred (function (c) {n.each ( b, funkcja (b, f) {var g = n.isFunction ([b]) && [b], e [f [1]] (function () {var NULL = n.extend (d):!}} d, e = {}, powrót d.pipe = d.then, n.each (b, funkcja (f) {var Array (e), j = new Array (e), k = nowa f | | g.resolveWith (k, c), g.promise ()}}); var H; n.fn.ready = function () {return J = n.access = funkcja (a, b, c, d, e, f, g) {var h = 0, i = a.length, J = null == c if ("obiekt" === N . typ (c)) {e = 0! do (h w c) n.access (b, h, c [h], 0, f, g)} if (void d == 0 &&! (e = 0, n.isFunction (d) | | (g = 0), j && (g (b.call (d), b = null):! (j = b, b = function ( , b, c) {powrotu j.call (N (a), c)})), b)) dla (, i> h, h +) b ([h], c, g d: d.call? ([D], h, b ([h] c))) powrót e: b.call j () bi ([0], c):? f}, n . acceptData = function () {! powrót 1 === a.nodeType | | 9 === a.nodeType | | + a.nodeType}; funkcja 0; var this.cache [c] | | (this.cache [c] = {}) c}, ustawienia: funkcję (a, b, c) {var d, e = this.key (), to f =. cache [e]; if ("ciąg" == typeof b) f [B] = c; if (n.isEmptyObject (f)) n.extend (this.cache [e], b); jeszcze do (d w b) f [D] = b [d]; return f}, otrzymujemy:? funkcja (a, b) {var c = this.cache [this.key ()]; powrócić void 0 === b c : c [b]}, dostępu: funkcja (a, b, c) {var d; powrócić void 0 === B | | b && "sznur" == typeof b && void 0 === c (d = this.get (b) próżnia 0 == d d:! this.get (, n.camelCase (b))):? (this.set (b, c), próżnia 0 c c == : b)}, usuń: funkcja (a, b) {var c, d, e, f = this.key (), g = this.cache [f], jeśli (void 0 === b) tego. Pamięć podręczna [f] = {}, w przeciwnym razie {n.isArray (b) d = b.concat (b.map (n.camelCase)): (e = n.camelCase (b), b w g d = [? b, e] (d = d = d ie [d]: d.match (e) | | []?)), c = d.length, natomiast (c -) usuwanie this.cache [[this.expando]]}}; var l = new K, M = nowy K, N = / ^ (: \ {[\ w \ W] * \} | \ [[\ w \ W] * \]) $ /, O = / ([AZ]) / g, funkcja P (a, b, c) {var d if (void c = void 0; return c} n.extend ({hasData: function () {return M.hasData () | | L.hasData ()}, dane: funkcja (a, b, c) {return M . dostępu (b, c)} removeData: function (b) {M.remove (b)
}, _data: Zastosowanie (a, b, c) {powrotu L.access (a, b, c)} _removeData: function (b) {L.remove (b)}}) n.fn . rozszerz ({dane: funkcja (a, b) {var c, d, e, f = to [0], g = f && f.attributes if (void e} return "obiekt" == typeof this.each (function () {M.set (to)}): J (ta funkcja (b) {var c, d = n.camelCase () if (f && pustki 0 === b) {if (c = M.get (f), void 0 == c!) return c; if (c = M.get (f, d), void 0! == c) return c; if (c = P (f, d, nieważne 0), void 0 == c) return c} else this.each (function () {var c = M.get (ta, d );! M.set (this, D, B) -1 == a.indexOf ("-") && void 0 == c && M.set (ta, a, b)})}, null, b, argumenty .! długości> 1, null, 0)}, removeData: function () {return this.each (function () {M.remove (to)})}}), n.extend ({kolejka: funkcja (a, b, c) {var d; powrót 0}, Dequeue: funkcja (a, b) {b = b | | "fx"; var f.stop, e.call (A, G, F)), d && f && f.empty.fire ()}, _queueHooks: function (a, b) {var c = b + "queueHooks"; powrót L.get (, c) | | L.access (A, C, {. puste: n.Callbacks ("raz pamięci") add (function () {L.remove ([b + "kolejki", c])})}) }}), n.fn.extend ({kolejka: funkcja (a, b) {var c = 2, obie strony "ciąg" = typeof w && (b = a, = "FX", C -), argumenty! . Długość <c n.queue (to [0]): void 0 === b to:? this.each (function () {var this.each (function () {n.dequeue (to)})}, clearQueue: function () {return this.queue (| | "fx", [])}, obietnica: funkcja (, b) {var c, d = 1, e = n.Deferred (), f = to, g = this.length, h = function () {- D | | e.resolveWith (f, [f])} , "sznur" = typeof w && (b =, = void 0) = | | "fx";! while (g -) c = L.get (f [g], a + "queueHooks") , c && c.empty && (d + +, c.empty.add (h)); return h (), e.promise (b)}}); var U = "niezdefiniowany"; k.focusinBubbles = "onfocusin" w var Z () {! Powrócić 0} Funkcja $ () {! Powrót 1} Funkcja _ () {try {return l.activeElement} catch () {}} n.event = {global: {}, dodać: funkcję ( , b, c, d, e) {var ! typeof n == U && n.event.triggered == b.type n.event.dispatch.apply, argumenty (a):? nieważne i [o])} else do (i) o w n.event.remove (, o + b [j], c, d, 0);! n.isEmptyObject (i) && (Usuń r.handle, L . usunąć (A, "wydarzenia"))}}, spust: funkcja (b, c, d, e) {var n.Event (q, "obiekt" == typeof b && b), b.isTrigger = e? 02:03, b.namespace = r.join ("."), b.namespace_re = b.namespace? nowy RegExp (" (^ | \ \.) "+ r.join (" \ \ (: * \ \ |).?.. ") +" (\ \ | $.) "): null, b.result = nieważne 0, h && (d [k] = h)), b.result}}, wysyłka: function () {= n.event.fix (); var 0! == E && (a.result = e) ===! 1 && (a.preventDefault (), a.stopPropagation ()))} powrócić k.postDispatch && k.postDispatch.call (to), a.result} }, Ładowarki: funkcja (a, b) {var ", Unieważnienie h <b.length && g.push ({elem: to, Ładowarki: b.slice (h)}), g}, rekwizyty:. "altKey pęcherzyki cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey cel timestamp widok której" split ("") , fixHooks: {}, keyHooks: {rekwizyty: "char charCode keyCode przycisk" split (""), filtry:. funkcja (a, b) {return wartość null == a.which && (a.which = null = b!. charCode b.charCode:? b.keyCode), a}}, mouseHooks: {rekwizyty: "przycisk przycisków clientX clientY offsetX offsetY pageX Pagey screenX screenY toElement" split (""), filtr:. funkcji (a, b) {var c, d, e, f = b.button; powrót 0 === f | | (a.which = 1 & f 01:02 & f 03:04 & f 02:00??)}}, Naprawić: function () {if ([n.expando]) return; var n.Event (f), b = d.length, podczas gdy (b -) c = d [b] [c] = f [c] powrotnym ! to == _ () && this.focus (this.focus (), 1!): void 0}, delegateType: "focusIn"}, rozmycie: {wyzwalania: function () {return to === _ () && this.blur (this.blur (), 1!): void 0}, _default: function () {return n.nodeName (a.target, "a")}}, beforeunload: {postDispatch: function () {void e = n.extend (nowa to instanceof F, G, jeśli ("obiekt" == typeof) {"ciąg" = typeof b && (c = c | | b, b = void 0);! dla (gw) this.on (g, b, c, [g], e);} czy to powrót (null == c && wartość null == d (d = b, c = b = void 0?): null == d && ("ciąg" == typeof b (? ! d = c, c = void 0): (d = c, c = b, b = void 0)), d === 1) d = $; else if (d) zwrotu tego, powrót 1 == = e && (f = d, d = function () {return this.on (a, b, c, d, 1)}, off: funkcja (a, b, c) {var d, e, jeśli (&& a.preventDefault && a.handleObj) powrót ) {for (e w a) this.off (E, B [k]), podobnego do tego}! zwrotu (b === 1 | | "funkcja" == typeof b) && (c = b b = void 0), c === 1 && (c = $), this.each (function () {n.event.remove (ta,, c, b)})}, spust: funkcja (, b) {return this.each (function () {n.event.trigger (A, B, twoja)})} triggerHandler: function (a, b) {var c = to [0]; n return c?. event.trigger (!, b, c, 0): void 0}}); var jb (a, b) {return WK () {return a.type = (null! == a.getAttribute ("Typ")) + "/" + a.type,} funkcja lb () {var b = gb.exec (a. typ); powrót b a.type = b [1]:? a.removeAttribute ("Typ"),} mb funkcyjne (a, b) {for (var c = 0, d = a.length, d> c c +) L.set (! [c] "globalEval" b | | L.get (b [c] "globalEval"))} function nb (b) {var c, d, e, f, g, h, i, j, jeżeli (1 === b.nodeType) {if (L.hasData () && (f = L.access () g = L.set (b, f) , j = f.events)) {delete g.handle, g.events = {}; dla (e w OB (b) {var void 0 === b | | b && n.nodeName (a, b) n.merge ([], c): c} Funkcja PB (a, b) {var? nb (a, h); powrót g = ob (h, "skrypt"), g.length> 0 && mb (G, I && ob ("script")!), h}, buildFragment: funkcja (a, b, c , d) {for (var k}, cleanData: function () {for (var b, c, d, e, f = n.event.special, g = 0; void 0 == (c = [g]); g + +) { jeśli (n.acceptData (c) && (e = c [L.expando], e && (b = L.cache [e]))) {if (b.events) do (d), f, w b.events [d ?] n.event.remove (c, d): n.removeEvent (c, d, b.handle) L.cache [e] && usunąć L.cache [e]} usunąć M.cache [c [M.expando ]]}}}), n.fn.extend ({text: function () {return J (to, function () {return void this.domManip (argumenty, function () {if (1 === this.nodeType | | 11 === this.nodeType | | 9 === this.nodeType) {var b = jb (to); b.appendChild ()}})}, poprzedź: function () {return this.domManip (argumenty, function () {if (1 === this.nodeType | | 11 === this.nodeType | | 9 === this.nodeType) {var b = jb (to); b.insertBefore (, b.firstChild)}})}, przed: function () {return to}, pusta: function () {for (var a, b = 0, NULL = (= to [b]), b + +!) 1 === a.nodeType && (n.cleanData (ob (, 1! )) a.textContent = ""), podobnego do tego} klon:! funkcji (b) {zwrócić = NULL == 1: b = null == b: b, ten. map (function () {return n.clone (ta,, b)})}, html: function () {return J (ten, function () {var b = to [0] | | {}, c = 0, d = this.length if (void 0 === && 1 === b.nodeType) powrócić b.innerHTML if ("ciąg" == typeof = arguments [0]; powrót this.remove (, 0!)} domManip: function (b) {= e.apply ([]), var c, d, f, g, h, i, j = 0, l = this.length, m = to, o = l, 1, p = [0], q = n.isFunction (p), jeżeli (q | | l> 1 && "sznur" == typeof t && k.checkClone && eb! . badania (p)) return this.each (function (c) {var this.pushStack (d)}}); var qb, rb = {;} Funkcja SB (b, c) {var e.detach (), f} Funkcja tb () {var b = l, c = rb [];! powrót c | | (c = SB (a, b), "brak" == c && C | | ( QB = (QB | | n ("<iframe frameborder = '0 'width = '0' ub = / ^ marża /, czas = new RegExp ("^ (" + P + ") (! px?) [az%] + $", "i"), WB = function () {a.ownerDocument powrotu. defaultView.getComputedStyle (null, null);} Funkcja XB (a, b, c) {var d, e, f, g, h = a.style; powrót !? 0 == g g+ "": Funkcja yb g} (a, b) {return {get: function () {return () void delete this.get:. (This.get = b) zastosowanie (w tym , argumenty funkcji)}}}! () {var g (), b}, boxSizingReliable: function () {wartość null powrót == c && g (), c}, reliableMarginRight: function () {var b, c = f.appendChild (l.createElement ("div")); powrót e, f, g = {}; dla (f w b) g [f] = a.style [f], a.style [F] = b [f], e = c.apply (A, D | | []), dla (f w b) a.style [f] = g [f], powrót e};?! |-c var zb = / ^ (brak tabeli ([szt.]). +) / Ab = new RegExp ("^ (" + P + ") (. *) $", "i"), Bb = nowy Fb (a, b) {if (bw) return b; var c = b [0] toUpperCase () + b.slice (1), d = B, E = Eb.length;. Natomiast (e - ) if (b = EB [e] + c, b) w dwie strony w B; powrót d} Funkcja Gb (a, b, c) {var d = Ab.exec (b); powrót d Math.max (0 d [1] - (C | | 0)) + (d [2] | | "px") b} funkcję hemoglobiny (a, b, c, d, e) {for (var g funkcja} Ib (b, c) {var e, d = && g (k.boxSizingReliable () | | e === a.style [b]) e = parseFloat (e) | | 0} Powrót e + Hb (a, b, c | | (g? "granica": "px" funkcja "content"), d, f) +} Hi (a, b) {for (var } n.extend ({cssHooks: {kryjące: {get: function (a, b) {if (b) {var e, f, g, h = n.camelCase (b), i = a.style; powrót b = n.cssProps [h] | | (n.cssProps [h] = Fb (i, h)), g = n.cssHooks [b] | | n.cssHooks [h], nieważne 0 === c g && "dostać" w g && void 0 == (e = g.get (, 1, d)!) e?!: i [b]: (f = typeof g && próżnia 0 === (c = g.set (c, d)) | | (i [b] = C)), pozbawiony 0)}} CSS funkcją (a, b, c, d) { var e, f, g, h = n.camelCase (b); powrót b = n.cssProps [h] | | (n.cssProps [h] = Fb (a.style, h)), g = n.cssHooks [b] | | n.cssHooks [h], g && "dostać" w g && (! e = g.get (, 0, c)), void 0 === e && (e = XB (a, b, d )), "normalny" === e && bw ? c zb.test (n.css ("display")) && 0 === a.offsetWidth n.swap (, Cb, function () {return Ib (a, b, d)}): IB (a, b, d): void 0}, ustaw: funkcja (a, c, d) {var e = d && wb (); powrót b n.swap ({display: "inline-block"}, XB, ["marginRight"]): void d = 0, e = {}, f = "ciąg" == typeof c c.split (""): [c]; 4> d, d + +) e [+ R [d] + b] = f [d] | | f [D-2] | | f [0];}} return e, ub.test () | | (n.cssHooks [a + b] zestaw = Gb.)}), n. fn.extend ({css: funkcja (a, b) {return J (to, function (a, b, c) {var d, e, f = {}, G = 0, jeśli (n.isArray (b) ) {for (d = wb (a), e = b.length, e> g g+ +) m [b [g]] = n.css (b [g], 1, d),! powrotnej f } return void 0 == c n.style (a, b, c):? n.css (a, b)}, a, b, arguments.length> 1)}, show: function () {return Jb (! to, 0)}, hide: function () {return Jb (to)}, przełącznik: function () {return "logiczna" == typeof this.show ():? this.hide () : this.each (function () {?. S (ta) n () show (). n (to) ukryj ()})}}); funkcja Kb (a, b, c, d, e) {return new ? = Kb.propHooks [this.prop]; powrócić && a.get a.get (ta): Kb.propHooks._default.get (to)}, uruchom: function () {var b, c = Kb.propHooks [this.prop]; powrót b; powrót }, huśtawka: function () {return.5-Math.cos (* Math.PI) / 2}}, n.fx = Kb.prototype.init, n.fx.step = {}; var Lb , Mb, Nb = / ^ (: przełącznik | pokaż | ukryj?) $ /, Ob = new RegExp ("^ (: ([+ -]) = |) (" + P + ") ([az%] * ) $ "," i "), Pb = / queueHooks $ /, Qb = [Vb], Rb = {" * ": [funkcja (a, b) {var h = h | | "0,5", g / = h, n.style (c.elem,, g+ f);! natomiast (h! == (h = c.cur () / d) && 1 = = h && - i)} return e && (? g = c.start = + g | | + d | | 0, c.unit = f, c.end = e [1] G+ (e [1] +1) * e [2]: + e [2]), c}]}; funkcja SB () {return setTimeout (function () {Lb = void 0}), LB = n.now)} function (Tb (, b) {var c, d = 0, e = {wysokość:}; for (b = b 01:00, 4> d, d + = 2-b) c = R [D] e ["margines" + n] = E ["wypełnienie" + c] = powrotnym b && (e.opacity = e.width =), e} funkcji Ub (a, b, c) {for (var d, e = (Rb [b] | | []) concat (Rb ["*"]), f = 0, g = e.length;.. g> f, f + +) if (d = e [f] call (c, b, )) return d} Funkcja Vb (a, b, c) {var . n.queue ("FX") Długość | | h.empty.fire ()})})), 1 === a.nodeType && ("wysokość" w B | | "szerokość" w w punkcie b), jeżeli (e = b [d], Nb.exec (e)) {if (usuwanie b [d], f = F | |? "przełącznik" === e, e === (p "ukryj ":" show ")) {if ("! show "== e | | Q | | void 0 === q [d]), w dalszym ciągu, p = 0} m [d] = q && q [d] | | n.style (d)} else J = próżnia 0 if (n.isEmptyObject (m)) "inline" === ("brak" === tb j (a.nodeName): j?) && (o.display = j); else {q "ukryte" w? b; L.remove ("fxshow"), w przypadku (b wm) n.style (b, m [b])}) do (d) w m g = Ub (p q [d? ]: 0, d, l), d w q | | (q [d] = g.start, p && (g.end = g.start, g.start = "Szerokość" === D | | "wzrost" ? === d 1:0))}} function Wb (b) {var c, d, e, f, g, dla (cw) if (d = n.camelCase (c), E = b [d] f = [c] n.isArray (f) && (e = f. [1], Rf = [c] = m [0]), c! && d == ([d] = f skasować [C]), g = n.cssHooks [d, g] && "poszerzenia" w gramach) {f = g.expand (f) usuwanie [D], dla (C) f-C w | | ([c] = f [c], B [c] = e)} w przeciwnym razie B [d] = e} funkcji Xb (a, b, c) {var d, e, f = 0, g . = Qb.length, h = n.Deferred () zawsze (function () {delete i.elem}), i = function () {if (e) powrót 1;! for (var d = n.Tween (, j.opts, b, c, j.opts.specialEasing [b] | | j.opts.easing); j.tweens.push powrotu (d), d}, stop: funkcja ( b) {var c = 0, d = b j.tweens.length: 0; if (e) powrót ten, dla (e = 0, d> c, c + +) j.tweens [c] uruchomienie (1?!. ); powrót d; powrót "); For (var d = a "obiekt" && == typeof ? d.duration = n.fx.off 0: "numer" == typeof d.duration d.duration: d.duration w e = n.isEmptyObject (), f = n.speed (b, c, d), g = funkcja () {var b = Xb (to n.extend ({}), f), (e | | L.get (ten, "bramka")) && b.stop (0);} powrót g.finish = g, e | | f.queue === 1 this.each (g): to!. Kolejka (f.queue, g)}, stop: funkcja (a, b, c) {var d = function () {var b = a.stop; usunąć a.stop, b (c);} return "ciąg "(| fx", [] = typeof w && (c = B, B = A = void 0), b && == 1 && this.queue |)! ", this.each (function () {var b ! = 0, e = null = && + "queueHooks", f = n.timers, g = L.get (to);. if (e) g [e] && g [e] przestać && d (g [e]); jeszcze do (e w == 1 && (= | | "FX")!, this.each (function () {var c.finish})}}), n.each (["przełącznik", "przedstawienie", "ukryj"], funkcja (a, b) {var c = n.fn [b]; n.fn [b] = funkcja (a, d, e) {wartość null powrót == | | "logiczna" == typeof this.animate (b, c, d)}}), n.timers = [], n.fx.tick = function () {var = n.fx n.fx.speeds [] | |:?, b = b | | "fx", this.queue (b, funkcja (b, c) {var d = setTimeout (b, ); c.stop = function () {clearTimeout (d)}})}, function () {var Yb, Zb., $ b = n.expr.attrHandle; n.fn.extend ({attr: funkcja (a, b) {return J (to, n.attr, a, b, arguments.length> 1)}, removeAttr: function () {return this.each (function () {n.removeAttr (to)})}}), n.extend ({attr: funkcja (a, b, c) {var d, e , f = a.nodeType if (&& 3 == f && 8 == f && 2 == f!) typeof powrót 0 === C D && "dostać" w d && NULL == (E = d.get (a, b)) e:?!? (E = n.find.attr (a, b), null == e nieważne 0: e):! wartość null == c d && "SET" d == 0 && pustej (e = d.set (c, b)) e:? (a.setAttribute (b, c + "") c) nieważności n.removeAttr (b))
}, RemoveAttr: funkcja (a, b) {var c = a.value; powrócić a.setAttribute ("typ", b), c && (a.value = c), b}}}}}), Zb. = {zbiór: funkcja (a, b, c) {return c = $ b [b] | | n.find.attr; $ b [b] = funkcja (a, b, d) {var e f,; powrót d | | (f = $ b [b] $ b [b] = S, E = brak = c (b, d) b.toLowerCase () pusty, $ b [b] = f), e}}) var _b = / ^ (!?: Wejście | Zaznacz | textarea | przycisk) $ / i; n.fn.extend ({prop: funkcja (a, b) {return J (to, n.prop, A, B, arguments.length> 1)}, removeProp : function () {return this.each (function () {delete d, e, f, g = a.nodeType;! if (! && 3 == g && 8 == g && 2 == g) powrót f = 1 == g | | n.isXMLDoc (), f && (b = n.propFix [b] | |!! b, e = n.propHooks [b]), void 0 == c e && "zestaw" w e && void 0 == (d = e.set (a, c, b) ?) d: [b] = c: e && "dostać" w e && NULL == (d = e.get (a, b)) d:? a [b]}, propHooks: {tabIndex: {get: funkcja () {return b = a.parentNode; powrót ac = / [\ t \ r \ n \ f] / g; n.fn.extend ({addClass: function () {var b, c, d, e, f, g, h = "ciąg" == typeof &&, i = 0, j = this.length if (n.isFunction ()) return . "+ C.className +" ") zastąpi (ac," "):" ")) {f = 0, natomiast (e = b [f + +]) d.indexOf (" "+ e +" ") <0 && (d + ! = e + ""); g = n.trim (d), c.className == g && (c.className = g)} return to}, removeClass: function () {var b, c, d, e, f, g, h = 0 === arguments.length | | "sznur" == typeof &&, i = 0, j = this.length if (n.isFunction ()) return . "+ C.className +" ") zastąpi (AC," "):" ")) {f = 0, natomiast (e = b [f + +]), podczas gdy (d.indexOf (" "+ e +" ")> = 0) d = d.replace ("e" + + "" ""), g = n.trim (d): "", c.className == g && (c.className = g)} podobnego do tego }, toggleClass: funkcja (a, b) {var c = typeof; powrót "logiczna" == typeof b = "" + + "", c = 0, d = this.length, d> c, c + +) if (. 1 === ta [c] nodeType && ("". + ta [c] className + "") . wymienić (AC, "") indexOf (b)> = 0) return 0;}} powrót 1); var bc = / \ r / g; n.fn.extend ({val:.! function () {var b, c, d, e = to [0]; {if (arguments.length) return d = n.isFunction (), this.each (function (c) {var e; 1 === tego. nodeType && (e = d a.call (tego, c, n (to) val ()):.?, null == e e = "": "numer"? == typeof e e + = "": brak . IsArray (e) && (e = n.map (e, function () {wartość null powrót == "": + "?"})), b = n.valHooks [this.type] | | n. valHooks [this.nodeName.toLowerCase ()], b && "set" w pustej 0 && b == b.set (to, e, "wartość") | | (this.value = e))}); if (e) powrót b = n.valHooks [e.type] | |! n.valHooks [e.nodeName.toLowerCase ()], b && "dostać" w b && void 0 == (c = b.get (e, "wartość")) ? c: (? c = e.value, "sznur" == typeof c c.replace (bc, ""): wartość null == c "": c)}}}), n.extend ({valHooks: {opcja: {get:? function () {var b = n.find.attr ("wartość"); zwróci null = b b: n.trim (n.text ())}}, wybierz : {get: function () {for (var b; g.push (b)} return g}, ustaw: funkcja (a, b) {var n.isArray (b) a.checked = n.inArray (n () val (), ur.)> = 0:. nieważne 0}}, k.checkOn | | (n.valHooks [to] get = function () {wartość null powrót === a.getAttribute ("wartość") "na":? a.value})}), n.each ("rozmycie ostrości focusln focusOut obciążenia zmiany rozmiaru przewijania rozładować kliknij DblClick mousedown MouseUp mousemove mouseover mouseout MouseEnter MouseLeave zmiana wybierz złożyć błąd keydown naciśnięcie keyup contextmenu ". split (" "), funkcja (a, b) {n.fn [b] = function (c) {return arguments.length> 0? this.on (b, null, c): this.trigger (b)}}), n.fn.extend ({unosić: funkcja (a, b) {return this.mouseenter (a) MouseLeave (B | | A. )}, wiążą: funkcja (a, b, c) {return this.on (null, b, c)}, rozpiąć: funkcja (a, b) {return this.off (null, b)} , delegat: funkcja (a, b, c, d) {return this.on (B, A, C, D)}, undelegate: funkcja (a, b, c) {return 1 === arguments.length to . off ("**"):? this.off (b, | | "**", c)}}); var cc = n.now (), dc = / \ /; n.parseJSON = function () {return JSON.parse (A + "")}, n.parseXML = function () {var b, c; if (| |! "brak powrotu ciąg" = typeof!); try { c = new DOMParser, b = c.parseFromString ("text / xml")} catch (d) {b = 0} return void (b |! |. b.getElementsByTagName ("parsererror") długość) && n.error ("Nieprawidłowy XML:" + a), b}; var EC, FC, GC = / # * $ /, hc = / ([i?]) _ = [^ &] * /, ic = / ^ (. .? *): [ rc () {function return (b, c) {"ciąg" = typeof b && (c = b, b = "*");! var sc (a, b, c, d) {var e = {}, f = oc ===; funkcja g (h) {var i;! powrót e [h] = 0, n.each ([h ] | | [], funkcja (a, h) {var j = h (b, c, d), powrót "sznur" = typeof J | | f | | f e [j] (i = J!?! ): void 0:! (b.dataTypes.unshift (j), g (j), 1)}), i} return g (b.dataTypes [0]) | | e ["*"] && g (" * ")} funkcję TC (b) {var c, d, e = n.ajaxSettings.flatOptions | | {},! dla (w b) próżnia 0 == b [c] && ((E [c ?]: D | | (d = {})) [C] = b [c]); powrót && d n.extend (0, d),} uc funkcja (a, b, c) {var d, e, f, g, h = a.contents, i = a.dataTypes, natomiast ("*" === I [0]) i.shift (), void 0 === d && (d =. mimeType | | b.getResponseHeader ("Content-Type")) if (d) (e), jeśli w godz (h [e] && h [e] testy (d.)) {i.unshift (e), przerwa } if (i [0] w c) f = i [0]; else {for (w c e) {if | {(i [0] | a.converters [e + "," + i [0]]) f = e; break} g | | (g = e)} f = f | | g} return f (f! == I [0] && i.unshift (f), c [f]): void 0} Funkcja vc (a, b, c, d) {var e, f, g, h, i, j = {} k = a.dataTypes.slice () if (k) [1] dla (gw if (! "*" == I && i == f) {if (g = j [i + "," + f] | | j! ["*" + f], g) do (e w j) if (h = e.split (""), h [1] === f && (g = j [i + "" + H [0]] | | j ["* try {b = g (b)} catch (l) {return {stan: "parsererror", błąd:? g l: "Konwersja z" + i + ", aby charset = UTF-8 ", przyznaje: {" * ": PC, tekst:" text / plain ", html:" text / html ", xml:" application / xml text / xml ", JSON:" application / json , tekst ": String," html tekst ": 0," json tekst ": n.parseJSON," xml text ": n.parseXML}, flatOptions: {url: 0, kontekst: 0}}, ajaxSetup: funkcja (a, b) {return && (b =, = void 0), B = b | | {}; var b if (2 === t) {if {f = {} (f!), natomiast (b = ic.exec (e)) f [. b [1] toLowerCase (b)] = [2]} ? b = f [a.toLowerCase ()]} return wartość null == b wartość null: b}, getAllResponseHeaders: function () {return 2 === t E: null}, setRequestHeader: funkcja (a, b) {var c = a.toLowerCase (); powrót t | | (a = s [C] = s [c] | | r [] = b),}, overrideMimeType: function () {return T | | (k.mimeType =), to}, statusCode: function () {parametr b, if () if (2> t) dla (bw) q [b] = [q [b] [ b]]; v.always indziej ([v.status]);}, return to przerwać: function () {var b = | | u, powrót k.data && (k.data = n.param (k.data, k.traditional)), sc (nc, k, b, v), 2 === t) powrót "+ PC +" q = 0,01 ":" "): k.accepts [" * "]); for (j w v.abort (); u = "Anuluj"; for (j w, x (1, w)}} else x (-1, "nie Transport"); funkcji x (a, b, f, h) {var j, r, s, u, w, x = b; 2! == t && (t = 2, g && clearTimeout (g), c = nieważne v}, getJSON: funkcja (a, b, c) {n.get powrotu (a, b, c, "json")}, getScript: funkcja (a, b) {n.get powrotu (, nieważne 0, b, "skrypt")}}), n.each (["dostać", "posterunek"], funkcja (a, b) {n [b] = funkcja (a, c, d, e) {return n. isfunction (c) && (e = e | | d, d = c, c = nieważne this.on (b)}}), n._evalUrl = function () {return b; powrót . = to, natomiast (a.firstElementChild) = a.firstElementChild; powrotu}) dołącza (co)), niniejszy)} wrapInner: function () {powrót this.each (n.isFunction ()? funkcja (b) {. n (to) wrapInner (a.call (ta, b))}: function () {var b = n (to), c = b.contents (); c.length c.wrapAll (a): b.append ()})}, Opakowanie: function () {var b = n.isFunction (); powrót this.each (function (c) {n () wrapAll (b.? a.call (tego, c): a)})}, rozpakować: function () {return Bc (a, b, c, d) {var e;? If (n.isArray (b)) n.each (b, funkcja (b, e) {c | | xc.test () d (, e) BC (+ "[" + ("obiekt" == typeof eb: "") + "]", e, c, d)}) if (c | | "obiekt" ==! n.type (b)) d (b) w inny (e w punkcie b) BC (+ "[e" + + "]", B [k], c, d)} n.param = funkcja ( , b) {var for (cw) BC (c, [c], B, E), z powrotem d.join ("i") zastępuje (WC "+")} n.fn.extend ({serialize:. funkcji () {return n.param (this.serializeArray ())}, serializeArray: function () {return this.map (function () {var a = n.prop (this, "elementy"); powrót n?. makeArray (a):. tego}) filtr (function () {var a = this.type; powrót c = n (to) val ();. powrót Nowy XMLHttpRequest} catch () {}}; var w DC) DC [] ()}), k.cors = Fc && "withCredentials" w Fc, k.ajax = Fc = Fc, n.ajaxTransport (function () {var b;!! powrót k . Cors | | Fc && a.crossDomain {wysłać:? funkcja (c, d) {var E, F = a.xhr (), G = + + Cc if (f.open (a.type, a.url , a.async, a.username, a.password), a.xhrFields) do (e w w c) f.setRequestHeader (e, c [e]), b = function () {funkcja return () {b && (usunąć f.responseText {text: f.responseText}: void h}}, przerwać: function () {b && b ()}}: void 0}), n.ajaxSetup ({przyjmuje: {skrypt: "text / javascript, application / javascript, application / ECMAScript, application / x-ECMAScript" }, zawartość: {skrypt :/ (java | ECMA?) skrypt /}, konwertery: {"skrypt tekst": function () {return n.globalEval ()}}}), n.ajaxPrefilter ( "skrypt", function () {void Gc = [], Hc = / (=) \ \ \ /; n.ajaxSetup ({jsonp? (= I | | $?): "Callback", jsonpCallback: function () {var a = Gc.pop? () | | n.expando + "_" + cc + +;! wrócić tego [] = 0}}), n.ajaxPrefilter ("json jsonp", function (b, c, d) {var e, f, g, h = b.jsonp == 1 && (Hc.test (b.url) "url":!? "sznur" == typeof json "] = function () {return g | | n.error (e +" nie było 0}), "skrypt"):! Void 0}), n.parseHTML = funkcja (a, b, c) {if (| | "ciąg" = typeof) wartość null powrotu; "logiczna" == typeof b && (c = b, b = 1!), B = B | | l;! var d = v.exec () e = c && []; powrotu Ic = n.fn.load; n.fn.load = funkcja (a, b, c) {if powrócić Ic.apply (this, argumenty) ("ciąg" = typeof w && Ic!); Var d, e, f, g = ta, h = a.indexOf (""); return h> = 0 && (d = n.trim (a.slice (h)) = a.slice (0, h)), n.isFunction ( ? b) (c = b, b = próżnia 0) && b "obiekt" == typeof n.grep (n.timers, funkcja (b) {return a b.elem ===}) długość};. var Jc = a.document.documentElement; funkcja Kc () {return n.isWindow (a)? : 9 === a.nodeType && a.defaultView} n.offset = {setOffset: funkcja (a, b, c) {var ? b b.using.call (, m): l.css (m)}}, n.fn.extend ({offset: function () {if (arguments.length) void return 0 ===? to: this.each (function (b) {n.offset.setOffset (ta,, b)}); var b, c, d = to [0], e = {top: 0, w lewo: 0}, f = d && d.ownerDocument;? if (f) zwrot b = f.documentElement, n.contains (b, d) (typeof this.map (function () {var | | Jc})}}), n.each ({scrollLeft: "pageXOffset", scrollTop: "pageYOffset"}, function (b, c) {var d = "pageYOffset" === c; n.fn [ b] = function (e) {return J (ta funkcja (b e, f) {var g = Kc (b); return void ^ C (?. c = xb (b) vb.test (c) n () pozycja () [b] + "px": c) nieważności f = arguments.length && (c | | "logiczna" = typeof d!), g = c | | (d === 0 | | e === 0 "marża":!? "granica"); powrót J (ta funkcja (b, c, d) {var e; powrót ? 0 === d n.css (b, c, g) n.style (b, c, d, g)}, b, f d: próżnia 0, f null)}})}) n.fn.size = function () {return this.length}, n.fn.andSelf = n.fn.addBack, "funkcja" == typeof zdefiniować && define.amd && define ("jquery", [], function () {return n}); var Lc = a.jQuery, Mc = a $;.. powrót n.noConflict = function (b) {return $ === n && (a. $ = mc), b && a.jQuery === n && (a.jQuery = Lc), n}, typeof b === U && (. a.jQuery = $ = n), n});